Total Points: 100

You are welcome to discuss the problem with other students but the program you submit must be your own work. Please review the academic honesty policy for this course (see the syllabus). Please ask the instructor and IA for help if you get stuck. 

Upload only the file problem1.py to Courseworks.

Prologue: Ariadne's Thread
Ariadne, the daughter of Pasiphae and the Cretan king Minos, fell in love with Theseus, a Greek hero who came to Crete to slay the Minotaur, a monster half bull and half man that Minos kept in a subterranean labyrinth (maze). Ariadne gave Theseus a ball of yarn which he unwound as he entered the Labyrinth to slay the Minotaur. After slaying the Minotaur, Theseus followed the thread back to the entrance of the labyrinth and rejoined Ariadne.

In this assignment, we will implement a program that guides our hero Theseus through a randomly generated labyrinth to slay the Minotaur, leaving Ariadne's thread behind. We will represent the labyrinth with a numpy array, show it with matplotlib, and use recursion to help Theseus navigate through the labyrinth to find the Minotaur.

Chapter 1: The Labyrinth
In the first step, we will build and draw the labyrinth. Download the file maze.py Download maze.py(alternative download linkLinks to an external site.) and save it in the same folder as your file problem1.py. The file maze.py exports a function called generate(). When called, the function generates a new random maze and returns a tuple of three values: (width, height, plan). The values width and height are the dimensions of the maze. The value plan is a list of boolean values representing individual cells (squares) within the maze. If the value is True, the cell contains a wall. If it is False, the cell contains a corridor (passageway). The upper-left corner of the maze has coordinates [0, 0]. The entrance to the maze is always at the coordinates [0, 1].

Your first task is to create a function called build_labyrinth(width, height, plan):

def build_labyrinth(width, height, plan):
    # Implement the body of the function
    return labyrinth
The function takes the values returned by the maze generator and returns a two-dimensional Numpy array representing the labyrinth. Place Theseus at the entrance and Minotaur in the bottom-right corner at coordinates [-2, -2]. Use numpy.uint8 as the data type for the array and the following values to represent the content of each cell (square):

PATH     = 0  # The cell contains a passageway
WALL     = 1  # The cell contains a wall
THESEUS  = 2  # Theseus is in this cell
THREAD   = 3  # The cell contains Ariadne's thread
MINOTAUR = 4  # The Minotaur is in this cell
VISITED  = 5  # Special marker for the cells visited by Theseus
When you have the function implemented, generate a new maze, convert it to a labyrinth, and show the result with matplotlib:

from matplotlib import pyplot as plt
import maze

width, height, plan = maze.generate()
labyrinth = build_labyrinth(width, height, plan)
plt.imshow(labyrinth)
You should see an image that looks as follows:

labyrinth.png

The green square represents Theseus at the entrance and the yellow square represents the Minotaur.

Note: Both the Spyder editor and repl.it should be able to display the images generated by matplotlib. You can also develop your homework in a Jupyter notebook (the environment used in class) which is preinstalled in Anaconda. If you run into issues displaying the labyrinth and need help, please email Jan or one of the TAs and we will help you set it up. Also, don't worry about colors. Matplotlib selects colors automatically and it is fine if your color scheme is different from the example.

Hints for build_labyrinth():

The generator generates a 31x31 square maze by default. Thus, the shape of your numpy array representing the labyrinth should be (31, 31). You can pass two optional parameters to maze.generate() to generate a maze of a different size, for example, maze.generate(61, 41). Please make sure your function works correctly with rectangular mazes!
To place Theseus and Minotaur into the labyrinth, simply write the values that represent them into corresponding cells.
Chapter 2: The Slaying
Now that we have a labyrinth with Theseus and the Minotaur in it, we will develop a program that guides Theseus through the labyrinth to the Minotaur, leaving Ariadne's thread behind. We will create a function called slay(labyrinth, y, x) which takes the labyrinth produced by build_labyrinth() and a starting position (y, x) and records Theseus' path through the labyrinth to the Minotaur.

def slay(labyrinth, y, x):
    # Base case here
    # Recursive calls here
    pass # Replace this and implement the function
The function modifies the labyrinth to show the thread (dark-green) and also all the dead-end passages explored by the program (yellow). When you plot the labyrinth with plt.imshow() again after running slay(), you should see something like this:

path.png

The function slay() will systematically explore the labyrinth until it finds the Minotaur. You can implement a very simple recursive search strategy in your slay() function. The search will start at the entrance and in each step it will recursively explore the adjacent cells (if possible). The search ends when the Minotaur is found. A path from the entrance to the Minotaur is guaranteed to exist (the generator ensures that).

Recall from the lecture on recursion that a recursive function consists of two parts: (1) the base case, (2) recursive calls to itself with modified parameters bringing you closer to the solution.

Base case: The base case of the slay() function checks only the cell passed to the function via parameters. It checks if the cell contains the Minotaur, a wall, or whether the cell has been visited before. If the cell contains a wall or has been visited before, return False to indicate that this is a dead-end. If the cell contains the Minotaur, return True to indicate the beast has been slain. If the cell is neither visited, nor wall, nor Minotaur, mark the cell as visited and proceed to recursive calls.

Recursive calls: If we get to the recursive section of the function, that means the Minotaur has not been found and current cell is an unexplored passageway. Thus, we simply need to explore the labyrinth further. First, we call slay() on the cell to the right. If it returns True, the Minotaur has been found in that direction. We mark the current cell with Ariadne's thread and return True as well. Otherwise, we explore the cell to the bottom, left, and top in the same way. If none of these recursive calls return True, we are in a dead-end and need to tell the caller to backtrack by returning False.

Hints for slay():

Keep in mind which section of your function implements the base case and which implements the recursive calls. Solve those two parts separately. Review the notes from lecture12 if you get stuck.
Puth Ariadne's thread into the cell after the recursive calls have returned and only if one of them returned True. This essentially unwinds the thread backwards from the Minotaur to the entrance. This simplifies your base case because all base cases are run before the labyrinth is marked with the thread. 
You don't have to check for the labyrinth's bounds. It is surrounded by wall which will stop you no matter where you go.
Assume you will find the Minotaur. The labyrinth is generated in a way that guarantees a path from the entrance to the beast.
Chapter 3: Action!
Write a main program that generates a labyrinth, navigates Theseus to slay the Minotaur, and shows the result:

if __name__ == '__main__':
    # main program here
Optional: don't forget to try your program on a larger labyrinth and marvel at the result:

big-labyrinth.png

Submit your file problem1.py to Courseworks.

Epilogue: That's All Folks!
You made it through E1006 homeworks, congratulations! Take a second look at your slay() function. It solves a non-trivial real-world problem, yet the implementation itself is short and straightforward in hindsight. Sometimes, the recursive nature of a problem is hard to see at first. Once you see it, the implementation itself is usually very straightforward. Also, think about how you combined various libraries and techniques to solve this problem. You used Python recursion, numpy, and matplotlib, a significant portion of E1006's content! If you keep programming in Python, you will find this to be common.

Hope it was fun!
